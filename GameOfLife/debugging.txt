One bug that I encountered was when I had already implemented the logic that basically counted the neighbors a specific cell had. The problem that I ran into was I was using that logic in order to let the program know when to kill, create, or leave alone a specific cell. When I ran the code, and ticked the simulation to the next generation. My next generation did not match what it was supposed to look like according to the test documents. My first assumption was that there was something wrong with my math calculations for detecting neighbors. So, I grabbed a blank sheet of paper and manually performed a generation using my calculations which worked as I expected them to so I knew there was nothing wrong with my math. My next, debugging strategy was to basically pick a cell on my grid and create a bunch of if statements in my counting num neighbors function for that cell to basically print a certain sentence when a neighbor was detected. So I picked a cell with one neighbor, but when I ran the program the sentence printed twice which was not supposed to happen. So doing different kinds of print statements I was able to isolate the specific cell at which my program qualified as a “neighbor”. The results I found were peculiar because while my program counted the cell that was actually a neighbor to my cell it also counted a blank spot one row up and a column to the right as also a valid neighbor. Then I looked at what my result for the next generation was supposed to look like and realized that in the next generation there was an valid neighbor in that cell that my program had counted. From this I was able to determine that because I was changing my grid in row major order without first making a copy of it. As the grid is changing so are the neighbors resulting in an inaccurate grid. To fix this problem, I made a copy of the grid changed the cells in that grid while detecting the neighbors in the original grid and then setting the original grid to the copied grid once the copied grid had been fully modified. 